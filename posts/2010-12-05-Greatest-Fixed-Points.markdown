---
title: Greatest Fixed Points and Anamorphisms in C#
author: Phil Freeman
date: 2010/12/05
description: An encoding of greatest fixed points in C#, with streams as an example.
tags: C#, Recursion
---

As promised in my last post, I\'m now going to go over how to encode greatest fixed point types and their anamorphisms in C# using existentials.

A recap: we use the isomorphisms

> exists X. T ~ forall R. (forall X. T -> R) -> R
>
> \\(pack X x). \\R. \\f. f x

and

> Nu F ~ exists X. X * (X -> F X)
>
> \\x. pack x out

where the second morphism has an inverse given by

> \\(pack X x). \\f. ana f x

where `ana f` denotes the anamorphism generated by `f`.

As an example, we are going to treat the case of infinite streams over an alphabet A:

> Stream A := Nu (\\X. A * X)

Let\'s first interpret the second isomorphism above in this context. We have

> Stream A ~ exists X. X * (X -> X * A)

The packed type here acts as an indicator of the position in the stream. We could take `X = int`. For constant streams, we could even let `X = ()`, the unit type. Then, we can interpret the existential package `pack X a f` as the stream with first few elements `a`, `outr (f a)`, `outr f (outr (f a))`, \...

Let\'s translate this into C#. First, our definition of a stream, using the first isomorphism above to encode existentials as universals:

    struct StreamF<A, T>
    {
        public T Seed { get; set; }
        public Func<T, Tuple<T, A>> Generator { get; set; }
    }

    interface StreamFunction<A, R>
    {
        R Apply<T>(StreamF<A, T> n);
    }

    interface Stream<A>
    {
        R Apply<R>(StreamFunction<A, R> f);
    }

With that definition, we can proceed to define anamorphisms in the way one would expect:

    class AnaStream<A, T> : Stream<A>
    {
        private readonly StreamF<A, T> sf;


        public AnaStream(StreamF<A, T> sf)
        {
            this.sf = sf;
        }

        public R Apply<R>(StreamFunction<A, R> f)
        {
            return f.Apply<T>(sf);
        }
    }

    public static Func<T, Stream<A>> Ana<A, T>(Func<T, Tuple<T, A>> generator)
    {
        return seed => new AnaStream<A, T>(new StreamF<A, T>
        {
            Seed = seed,
            Generator = generator
        });
    }

With anamorphisms under our belt, we can now define constant streams with ease:

    public static Stream<T> Const<T>(T t)
    {
        return Ana<T, Unit>(u => Tuple.Create<Unit, T>(u, t))(new Unit());
    }

with `Unit` here denoting any one-point type.

Consing an element onto the front of a stream is a little tricky. The idea is to replace the underlying type of the existential package T with the type `Maybe T := 1 + T`. Here the unit type corresponds to the head of the new stream and the T corresponds to the tail. In order to get at the underlying type of the package, we have to wrap any `StreamFunction<A>` object which will be responsible for unpacking the existential package:

    class ConsFunction<A, R> : StreamFunction<A, R>
    {
        private A head;
        private StreamFunction<A, R> tailFunction;

        public ConsFunction(StreamFunction<A, R> tailFunction, A head)
        {
            this.head = head;
            this.tailFunction = tailFunction;
        }

        public R Apply<T>(StreamF<A, T> n)
        {

            return tailFunction.Apply<Either<Unit, T>>(new StreamF<A, Either<Unit, T>>
            {
                Seed = Either<Unit, T>.inl(new Unit()),
                Generator = pair => pair.Case(
                    u => Tuple.Create<Either<Unit, T>, A>(
                        Either<Unit, T>.inr(n.Seed), head),
                    new Func<T, Tuple<Either<Unit, T>, A>>(t =>
                    {
                        Tuple<T, A> next = n.Generator(t);
                        return Tuple.Create<Either<Unit, T>, A>(
                            Either<Unit, T>.inr(next.Item1), next.Item2);
                    }))
            });
        }
    }

    class ConsStream<A> : Stream<A>
    {
        private Stream<A> tail;
        private A head;

        public ConsStream(Stream<A> tail, A head)
        {
            this.tail = tail;
            this.head = head;
        }

        public R Apply<R>(StreamFunction<A, R> tailFunction)
        {
            return tail.Apply(new ConsFunction<A, R>(tailFunction, head));
        }
    }

    public static Stream<A> Cons<A>(this Stream<A> s, A a)
    {
        return new ConsStream<A>(s, a);
    }

Here, the Either class is used to represent sum types. It has two constructors and a generic method used to destruct its values:

    class Either<A, B>
    {
        private bool flag;
        private A a;
        private B b;

        private Either() { }

        public static Either<A, B> inl(A value)
        {
            return new Either<A, B>
            {
                flag = true,
                a = value
            };
        }

        public static Either<A, B> inr(B value)
        {
            return new Either<A, B>
            {
                flag = false,
                b = value
            };
        }

        public T Case<T>(Func<A, T> aFunc, Func<B, T> bFunc)
        {
            return flag ? aFunc(a) : bFunc(b);
        }
    }

To take an element from the head of a stream, we can use the same generator function, but shift the seed value by one iteration:

    class NextStream<A, T> : Stream<A>
    {
        private Stream<A> s;
        private StreamF<A, T> n;

        public NextStream(Stream<A> s, StreamF<A, T> n)
        {
            this.s = s;
            this.n = n;
        }

        public R Apply<R>(StreamFunction<A, R> f)
        {
            return f.Apply<T>(new StreamF<A, T>
            {
                Seed = n.Generator(n.Seed).Item1,
                Generator = n.Generator
            });
        }
    }

    class NextFunction<A> : StreamFunction<A, Tuple<A, Stream<A>>>
    {
        private Stream<A> s;

        public NextFunction(Stream<A> s)
        {
            this.s = s;
        }

        public Tuple<A, Stream<A>> Apply<T>(StreamF<A, T> n)
        {
            return Tuple.Create<A, Stream<A>>(n.Generator(n.Seed).Item2,
                new NextStream<A, T>(s, n));
        }
    }

    public static Tuple<A, Stream<A>> Next<A>(this Stream<A> s)
    {
        return s.Apply<Tuple<A, Stream<A>>>(new NextFunction<A>(s));
    }

Next time I plan to give a treatment of another greatest fixed point type - the conatural numbers - and their arithmetic.
