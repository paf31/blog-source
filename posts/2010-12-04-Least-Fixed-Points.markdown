---
title: Least Fixed Points and Catamorphisms in C#
author: Phil Freeman
date: 2010/12/04
description: An encoding of least fixed point types in C#, with finite lists as an example.
tags: C#, Recursion
---

I\'ve been trying to find a nice way to encode least fixed points in C# for a while. At first, I tried to define a functor interface. Unfortunately, due to C#\'s lack of type constructor polymorphism, there isn\'t really a nice way to do this in a type-safe way. However, there is a nice way to encode least fixed points without using the functorial structure at all.

We use the isomorphism

> Mu F ~ forall X. (F X -> X) -> X

The isomorphism is given by

> \\x. \\X. \\f. cata f x

where `cata f` denotes the catamorphism generated by `f`.

The inverse is given by

> \\y. y in

where `in :: F Mu F -> Mu F` is the algebra morphism. Note that `cata in = id` implies that this is indeed an inverse.

Unfortunately, we can\'t capture the type constructor F as a first-class value in C#, again due to the lack of type constructor polymorphism.

For now, let\'s take the example of cons lists. We have

> List A = Mu (\\X. 1 + A.X)

Translating this into C#, we have

    struct ListF<A, T>
    {
        public A a;
        public T t;
    }

    interface List<A>
    {
        T Cata<T>(Func<ListF<A, T>?, T> generator);
    }

How can we use this? Well, we can define the empty list:

    class EmptyList<A> : List<A>
    {
        public T Cata<T>(Func<ListF<A, T>?, T> generator)
        {
            return generator(null);
        }
    }

and a means of consing an element onto the front of an existing list:

    class Cons<A> : List<A>
    {
        public A x;
        public List<A> xs;

        public Cons(A x, List<A> xs)
        {
            this.x = x;
            this.xs = xs;
        }

        public T Cata<T>(Func<ListF<A, T>?, T> generator)
        {
            return generator(new ListF<A, T>
            {
                a = x,
                t = xs.Cata(generator)
            });           
        }
    } 

Finally we can turn a `List<A>` into an array `A[]`:

    public static T[] ToArray<T>(this List<T> list)
    {
        return list.Cata<T[]>(x => x.HasValue
            ? new T[] {x.Value.a}.Concat(x.Value.t).ToArray()
            : new T[0]);
    }

Some extension methods can make the creation of lists easier:

    public static List<T> Empty<T>()
    {
        return new EmptyList<T>();
    }

    public static List<T> Cons<T>(this List<T> list, T t)
    {
        return new Cons<T>(t, list);
    }

Now we can manipulate lists in the ways you would expect:

> Empty<int>().Cons(1).Cons(2).Cons(3).ToArray()
> [3, 2, 1]

We can also encode greatest fixed points using

> Nu F ~ Exists X. X * (X -> FX)

using the encoding of existentials which I described in my previous post, but that\'s a story for my next post.
